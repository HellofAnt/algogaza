# 객체 생성과 파괴
### 아이템1. 정적 팩터리 메서드

장점
1. 이름을 가질 수 있다.
2. 호출될 때마다 인스터스를 새로 생성하지 않아도 된다.
3. 반환 타입의 하위 타입 객체를 반환 할 수 있는 능력이 있다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

단점
1. 상속을 하려면 public이나 protected생성자가 필요하니 정적 메서드만 가지곤 하위 클래스를 생성 할 수 없다.
2. 정적 메서드는 프로그래머가 찾기 어렵다.

메서드에서 흔히 사용하는 명명 방식들
- from
- of
- valueOf
- instance or getInstance
- create or newInstance
- getType
- newType
- type 
---
### 아이템2. 생성자에 매개변수가 많다면 빌더를 고려하라

점층적 생성자 패턴도 쓸 수 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기가 어려워지는 경우가 많다. 자바 빈즈 패턴을 이용해(getter,setter)를 이용해도 매개변수를 점진적으로 추가 할 수 있지만 객체가 완전히 완성되기 까지는 일관성이 무너진 상태로 개발을 진행해야 한다. 퍄이썬이나 스칼라에 명명된 선택전 매개변수를 흉내낸 빌더 패턴을 쓴다면 가독성도 해결되고 불변의 법칙도 해결된다.

핵심은 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더패턴을 선택해 보라는 것이다.
(빌더패턴 주소 추가)

---

### 아이템3. 싱글턴을 하러면 private 생성자나 열거형으로 싱글턴임을 보장해야 한다. / 아이템4. 인스턴스화를 막으려면 private 생성자를 사용해라

정적 팩터리 방식이나, 직렬화를 하려는 클래스가 있다면 readResolve(정적 인스턴스를 돌려줘야 한다.) 메서드를 포함한 클래스를 구성하는게 좋다.

---

### 아이템4. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

하나 이상의 자원에 의존하고, 그 자원이 클랴스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는것이 좋다. 의존 객체를 만들어 구분지게 해주는편이 좋다.P

---

## 3장 모든 객체의 공통 메서드  
### 아이템10. equals 는 일반 규약을 지켜 재정의하라

equals 메서드는 재정의하기 쉬워 보이지만 곳곳에 함정이 도사리고 있어서 자칫하면 끔찍한 결과를 초래한다.
아래에서 예기하는 사항만 지키고 숙지하면 안정적인 equals 의 규약을 지킬 수 있다.
 
> equals 를 선언하면 안될때 참조해야할 체크리스트
- 각 인스턴스가 본질적으로 고유하다
- 인스턴스의 논리적 동치성을 검사할 일이 없다.
- 상위 클래스의 equals 가 같은 작용을 한다.
- equals 메서드를 호출할일이 없다.

> equals 에서 예기하는 동치관계
- 반사성
- 대치성
- 추이성
- 일관성
- null 아님

> 양질의 equals 를 구현하는 최적의 방법
- == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
- instanceof 연산자로 입력이 올바른 타입인지 확인한다.
- 입력을 올바른 타입으로 형변환 한다.
- 핵심 필드들이 모두 일치하는지 하나씩 검사한다.
- float 나 double 같은 필드들은 compare 를 활용한다.

많은 사람들이 equals 를 구현하면서 자문하지 않은 점들이 있다, equals 를 재정의할 땐 hashcode 도 반드시 재정의하는 것 과 
입력 타입을 Object 로 지키지 않는점 심지어 기본 오버라이드인데도 말이다.

구글의 AutoValue 프레임워크를 이용하면 좀 더 쉽게 equals 와 hashcode 구현에 들이는 시간을 줄일 수 있다.

